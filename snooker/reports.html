<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Relatórios - Ranking Sinuca</title>
    <script>
        // Prevent flash - apply theme immediately before any CSS loads
        (function() {
            try {
                const currentMode = localStorage.getItem('darkMode');
                const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                const shouldBeDark = currentMode === 'enabled' || (!currentMode && prefersDark);
                
                if (shouldBeDark) {
                    document.documentElement.className = 'dark-mode';
                    const style = document.createElement('style');
                    style.id = 'prevent-flash';
                    style.textContent = `
                        html, html.dark-mode, body, body.dark-mode { 
                            background-color: #121212 !important; 
                            color: #e0e0e0 !important; 
                        }
                        html.dark-mode h1, body.dark-mode h1 { color: #e0e0e0 !important; }
                        .container, #main-container { 
                            background-color: #1e1e1e !important; 
                            box-shadow: 0 2px 10px rgba(0,0,0,0.3) !important; 
                        }
                        html.dark-mode .container, html.dark-mode #main-container, 
                        body.dark-mode .container, body.dark-mode #main-container { 
                            background-color: #1e1e1e !important; 
                            box-shadow: 0 2px 10px rgba(0,0,0,0.3) !important; 
                        }
                        html.dark-mode .toggle-track, body.dark-mode .toggle-track { 
                            background-color: #16213e !important; 
                        }
                        html.dark-mode .toggle-thumb, body.dark-mode .toggle-thumb { 
                            transform: translateX(40px) !important; 
                            background-color: #0f3460 !important; 
                        }
                        html.dark-mode .toggle-thumb .fa-sun, body.dark-mode .toggle-thumb .fa-sun { 
                            opacity: 0 !important; 
                        }
                        html.dark-mode .toggle-thumb .fa-moon, body.dark-mode .toggle-thumb .fa-moon { 
                            opacity: 1 !important; 
                        }
                    `;
                    document.head.insertBefore(style, document.head.firstChild);
                } else {
                    const style = document.createElement('style');
                    style.id = 'prevent-flash';
                    style.textContent = `
                        html, body { 
                            background-color: #f8f9fa !important; 
                            color: #212529 !important; 
                        }
                        h1 { color: #212529 !important; }
                        .container, #main-container { 
                            background-color: white !important; 
                            box-shadow: 0 2px 10px rgba(0,0,0,0.1) !important; 
                        }
                        .toggle-track { 
                            background-color: #e9ecef !important; 
                        }
                        .toggle-thumb { 
                            transform: translateX(0) !important; 
                            background-color: #ffffff !important; 
                        }
                        .toggle-thumb .fa-sun { 
                            opacity: 1 !important; 
                        }
                        .toggle-thumb .fa-moon { 
                            opacity: 0 !important; 
                        }
                    `;
                    document.head.insertBefore(style, document.head.firstChild);
                }
                
            } catch(e) {}
        })();
        
        // Apply container styles immediately after DOM parsing starts
        (function() {
            function applyContainerStyles() {
                const container = document.getElementById('main-container') || document.querySelector('.container');
                if (container) {
                    const currentMode = localStorage.getItem('darkMode');
                    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                    const shouldBeDark = currentMode === 'enabled' || (!currentMode && prefersDark);
                    
                    if (shouldBeDark) {
                        container.style.setProperty('background-color', '#1e1e1e', 'important');
                        container.style.setProperty('box-shadow', '0 2px 10px rgba(0,0,0,0.3)', 'important');
                    } else {
                        container.style.setProperty('background-color', 'white', 'important');
                        container.style.setProperty('box-shadow', '0 2px 10px rgba(0,0,0,0.1)', 'important');
                    }
                }
            }
            
            // Try multiple times to catch container as early as possible
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', applyContainerStyles);
            }
            applyContainerStyles();
            setTimeout(applyContainerStyles, 0);
            setTimeout(applyContainerStyles, 10);
        })();
    </script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="style.css">
    <link rel="icon" href="https://github.com/lucaohost/lucaohost.github.io/blob/master/snooker-scoreboard/assets/favicon3.png?raw=true" />
</head>
<body>
    <div class="container" id="main-container">        
        <div class="text-end my-2">
            <button id="darkModeToggle" class="dark-mode-toggle" aria-label="Toggle dark mode">
                <span class="toggle-track">
                    <span class="toggle-thumb">
                        <i class="fas fa-sun"></i>
                        <i class="fas fa-moon"></i>
                    </span>
                </span>
            </button>
        </div>
        <h1 class="text-center my-4">Relatórios - Temporada 2026</h1>
        
        <div class="text-center mb-3">
            <a href="index.html" class="btn btn-style">
                <i class="fas fa-arrow-left"></i> Voltar ao Ranking
            </a>
        </div>
        
        <div class="text-center mb-4">
            <label for="period-select" class="me-2"><strong>Período:</strong></label>
            <select id="period-select" class="form-select d-inline-block" style="width: auto; display: inline-block;">
                <option value="">Selecione um período</option>
                <option value="last-match">Última Sinuca</option>
                <option value="full-season">Toda Temporada</option>
            </select>
        </div>
        
        <div id="report-content" style="display: none;">
            <div class="report-section mb-4">
                <h3 class="mb-3"><i class="fas fa-users"></i> Aproveitamento Individual</h3>
                <div id="individual-stats" class="table-responsive">
                    <table class="table table-striped">
                        <thead class="table-dark">
                            <tr>
                                <th>Jogador</th>
                                <th>Vitórias</th>
                                <th>Derrotas</th>
                                <th>Total</th>
                                <th>Aproveitamento</th>
                            </tr>
                        </thead>
                        <tbody id="individual-stats-body">
                        </tbody>
                    </table>
                </div>
            </div>
            
            <div class="report-section mb-4">
                <h3 class="mb-3"><i class="fas fa-trophy"></i> Dupla Mais Vencedora</h3>
                <div id="best-duo-wins"></div>
            </div>
            
            <div class="report-section mb-4">
                <h3 class="mb-3"><i class="fas fa-thumbs-down"></i> Dupla Mais Perdedora</h3>
                <div id="worst-duo-losses"></div>
            </div>
            
            <div class="report-section mb-4">
                <h3 class="mb-3"><i class="fas fa-chart-line"></i> Frequência de Duplas</h3>
                <div id="duo-frequency" class="table-responsive">
                    <table class="table table-striped">
                        <thead class="table-dark">
                            <tr>
                                <th>Dupla</th>
                                <th>Número de Vezes</th>
                            </tr>
                        </thead>
                        <tbody id="duo-frequency-body">
                        </tbody>
                    </table>
                </div>
            </div>
            
            <div class="report-section mb-4">
                <h3 class="mb-3"><i class="fas fa-fire"></i> Maiores Sequências</h3>
                <div id="streaks-content"></div>
            </div>
            
            <div class="report-section mb-4">
                <h3 class="mb-3"><i class="fas fa-calendar-week"></i> Aproveitamento do Período</h3>
                <div id="weekly-stats" class="table-responsive">
                    <table class="table table-striped">
                        <thead class="table-dark">
                            <tr>
                                <th>Jogador</th>
                                <th>Semana</th>
                                <th>Vitórias</th>
                                <th>Derrotas</th>
                                <th>Aproveitamento</th>
                            </tr>
                        </thead>
                        <tbody id="weekly-stats-body">
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
        
        <div id="no-data-message" class="alert alert-info text-center" style="display: none;">
            Nenhum dado disponível para o período selecionado.
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-database-compat.js"></script>
    <script>
        const firebaseConfig = {
            apiKey: "AIzaSyBsP4YSbp3qeK-ViyVXhWp8Jf3KetimveU",
            authDomain: "snooker-scoreboard2.firebaseapp.com",
            projectId: "snooker-scoreboard2",
            storageBucket: "snooker-scoreboard2.firebasestorage.app",
            messagingSenderId: "695835616380",
            appId: "1:695835616380:web:17fc21b1d88f26c63055f9"
        };
        
        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();
        
        const currentSeason = 2026;
        
        function getMatchesPath() {
            return `seasons/${currentSeason}/matches`;
        }
        
        function getPlayersPath() {
            return `seasons/${currentSeason}/players`;
        }
        
        document.addEventListener('DOMContentLoaded', function() {
            const toggleButton = document.getElementById('darkModeToggle');
            const body = document.body;
            const html = document.documentElement;
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            const currentMode = localStorage.getItem('darkMode') || (prefersDark ? 'enabled' : 'disabled');
            
            if (currentMode === 'enabled') {
                body.classList.add('dark-mode');
                html.classList.add('dark-mode');
            } else {
                body.classList.remove('dark-mode');
                html.classList.remove('dark-mode');
            }
            
            toggleButton.addEventListener('click', function() {
                const isDark = body.classList.contains('dark-mode');
                const newMode = !isDark ? 'enabled' : 'disabled';
                localStorage.setItem('darkMode', newMode);
                
                // Force page reload to apply theme correctly
                window.location.reload();
            });
            
            const periodSelect = document.getElementById('period-select');
            periodSelect.addEventListener('change', function() {
                if (this.value) {
                    generateReport(this.value);
                } else {
                    document.getElementById('report-content').style.display = 'none';
                    document.getElementById('no-data-message').style.display = 'none';
                }
            });
        });
        
        async function generateReport(period) {
            try {
                document.getElementById('report-content').style.display = 'block';
                document.getElementById('no-data-message').style.display = 'none';
                
                // Clear previous content
                document.getElementById('individual-stats-body').innerHTML = '';
                document.getElementById('best-duo-wins').innerHTML = '';
                document.getElementById('worst-duo-losses').innerHTML = '';
                document.getElementById('duo-frequency-body').innerHTML = '';
                document.getElementById('streaks-content').innerHTML = '';
                document.getElementById('weekly-stats-body').innerHTML = '';
                
                const matchesPath = getMatchesPath();
                const matchesSnapshot = await database.ref(matchesPath).once('value');
                const matchesData = matchesSnapshot.val() || {};
                let matches = Object.values(matchesData);
                
                if (matches.length === 0) {
                    document.getElementById('report-content').style.display = 'none';
                    document.getElementById('no-data-message').style.display = 'block';
                    return;
                }
                
                // Sort matches by date
                matches.sort((a, b) => {
                    const dateA = new Date(a.date || a.timestamp || 0);
                    const dateB = new Date(b.date || b.timestamp || 0);
                    return dateA - dateB;
                });
                
                // Filter by period
                let filteredMatches = matches;
                if (period === 'last-match') {
                    // Get the last match date (considering up to 1 day back)
                    const lastMatch = matches[matches.length - 1];
                    const lastMatchDate = new Date(lastMatch.date || lastMatch.timestamp);
                    // Set to start of that day (00:00:00)
                    lastMatchDate.setHours(0, 0, 0, 0);
                    // Go back 1 day
                    const cutoffDate = new Date(lastMatchDate.getTime() - 24 * 60 * 60 * 1000);
                    
                    filteredMatches = matches.filter(match => {
                        const matchDate = new Date(match.date || match.timestamp);
                        return matchDate >= cutoffDate;
                    });
                }
                
                if (filteredMatches.length === 0) {
                    document.getElementById('report-content').style.display = 'none';
                    document.getElementById('no-data-message').style.display = 'block';
                    return;
                }
                
                // Get players data
                const playersPath = getPlayersPath();
                const playersSnapshot = await database.ref(playersPath).once('value');
                const playersData = playersSnapshot.val() || {};
                
                // Generate all statistics
                generateIndividualStats(filteredMatches, playersData);
                generateBestDuo(filteredMatches);
                generateWorstDuo(filteredMatches);
                generateDuoFrequency(filteredMatches);
                generateStreaks(filteredMatches);
                generateWeeklyStats(filteredMatches, playersData);
                
            } catch (error) {
                console.error('Erro ao gerar relatório:', error);
                document.getElementById('report-content').style.display = 'none';
                document.getElementById('no-data-message').style.display = 'block';
                document.getElementById('no-data-message').textContent = 'Erro ao carregar dados: ' + error.message;
            }
        }
        
        function generateIndividualStats(matches, playersData) {
            const stats = {};
            
            matches.forEach(match => {
                const winners = Array.isArray(match.winners) ? match.winners : [match.winners];
                const losers = Array.isArray(match.losers) ? match.losers : [match.losers];
                
                winners.forEach(winner => {
                    if (!stats[winner]) {
                        stats[winner] = { wins: 0, losses: 0, total: 0 };
                    }
                    stats[winner].wins++;
                    stats[winner].total++;
                });
                
                losers.forEach(loser => {
                    if (!stats[loser]) {
                        stats[loser] = { wins: 0, losses: 0, total: 0 };
                    }
                    stats[loser].losses++;
                    stats[loser].total++;
                });
            });
            
            const statsArray = Object.entries(stats).map(([player, data]) => ({
                player,
                ...data,
                winRate: data.total > 0 ? ((data.wins / data.total) * 100).toFixed(2) + '%' : '0.00%'
            })).sort((a, b) => parseFloat(b.winRate) - parseFloat(a.winRate));
            
            const tbody = document.getElementById('individual-stats-body');
            statsArray.forEach(stat => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td><strong>${stat.player}</strong></td>
                    <td class="text-success">${stat.wins}</td>
                    <td class="text-danger">${stat.losses}</td>
                    <td>${stat.total}</td>
                    <td><strong>${stat.winRate}</strong></td>
                `;
                tbody.appendChild(row);
            });
        }
        
        function generateBestDuo(matches) {
            const duoWins = {};
            
            matches.forEach(match => {
                const winners = Array.isArray(match.winners) ? match.winners : [match.winners];
                if (winners.length === 2) {
                    const duo = winners.sort().join(' e ');
                    duoWins[duo] = (duoWins[duo] || 0) + 1;
                }
            });
            
            if (Object.keys(duoWins).length === 0) {
                document.getElementById('best-duo-wins').innerHTML = '<p class="text-muted">Nenhuma dupla vencedora encontrada.</p>';
                return;
            }
            
            const sortedDuos = Object.entries(duoWins).sort((a, b) => b[1] - a[1]);
            const bestDuo = sortedDuos[0];
            
            document.getElementById('best-duo-wins').innerHTML = `
                <div class="alert alert-success">
                    <strong>${bestDuo[0]}</strong> com <strong>${bestDuo[1]}</strong> vitória(s)
                </div>
            `;
        }
        
        function generateWorstDuo(matches) {
            const duoLosses = {};
            
            matches.forEach(match => {
                const losers = Array.isArray(match.losers) ? match.losers : [match.losers];
                if (losers.length === 2) {
                    const duo = losers.sort().join(' e ');
                    duoLosses[duo] = (duoLosses[duo] || 0) + 1;
                }
            });
            
            if (Object.keys(duoLosses).length === 0) {
                document.getElementById('worst-duo-losses').innerHTML = '<p class="text-muted">Nenhuma dupla perdedora encontrada.</p>';
                return;
            }
            
            const sortedDuos = Object.entries(duoLosses).sort((a, b) => b[1] - a[1]);
            const worstDuo = sortedDuos[0];
            
            document.getElementById('worst-duo-losses').innerHTML = `
                <div class="alert alert-danger">
                    <strong>${worstDuo[0]}</strong> com <strong>${worstDuo[1]}</strong> derrota(s)
                </div>
            `;
        }
        
        function generateDuoFrequency(matches) {
            const duoFrequency = {};
            
            matches.forEach(match => {
                const team1 = Array.isArray(match.winners) ? match.winners : [match.winners];
                const team2 = Array.isArray(match.losers) ? match.losers : [match.losers];
                
                // Both teams
                if (team1.length === 2 && team2.length === 2) {
                    const duo1 = team1.sort().join(' e ');
                    const duo2 = team2.sort().join(' e ');
                    
                    duoFrequency[duo1] = (duoFrequency[duo1] || 0) + 1;
                    duoFrequency[duo2] = (duoFrequency[duo2] || 0) + 1;
                }
            });
            
            const frequencyArray = Object.entries(duoFrequency)
                .sort((a, b) => b[1] - a[1]);
            
            const tbody = document.getElementById('duo-frequency-body');
            if (frequencyArray.length === 0) {
                tbody.innerHTML = '<tr><td colspan="2" class="text-center text-muted">Nenhuma dupla encontrada.</td></tr>';
                return;
            }
            
            frequencyArray.forEach(([duo, count]) => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td><strong>${duo}</strong></td>
                    <td>${count}</td>
                `;
                tbody.appendChild(row);
            });
        }
        
        function generateStreaks(matches) {
            // Sort matches by date
            const sortedMatches = [...matches].sort((a, b) => {
                const dateA = new Date(a.date || a.timestamp || 0);
                const dateB = new Date(b.date || b.timestamp || 0);
                return dateA - dateB;
            });
            
            // Individual player streaks
            const playerWinStreaks = {};
            const playerLossStreaks = {};
            const playerCurrentWinStreak = {};
            const playerCurrentLossStreak = {};
            
            // Duo streaks
            const duoWinStreaks = {};
            const duoLossStreaks = {};
            const duoCurrentWinStreak = {};
            const duoCurrentLossStreak = {};
            
            sortedMatches.forEach(match => {
                const winners = Array.isArray(match.winners) ? match.winners : [match.winners];
                const losers = Array.isArray(match.losers) ? match.losers : [match.losers];
                
                // Individual streaks
                winners.forEach(winner => {
                    playerCurrentLossStreak[winner] = 0;
                    playerCurrentWinStreak[winner] = (playerCurrentWinStreak[winner] || 0) + 1;
                    if (playerCurrentWinStreak[winner] > (playerWinStreaks[winner] || 0)) {
                        playerWinStreaks[winner] = playerCurrentWinStreak[winner];
                    }
                });
                
                losers.forEach(loser => {
                    playerCurrentWinStreak[loser] = 0;
                    playerCurrentLossStreak[loser] = (playerCurrentLossStreak[loser] || 0) + 1;
                    if (playerCurrentLossStreak[loser] > (playerLossStreaks[loser] || 0)) {
                        playerLossStreaks[loser] = playerCurrentLossStreak[loser];
                    }
                });
                
                // Duo streaks
                if (winners.length === 2) {
                    const duoWin = winners.sort().join(' e ');
                    duoCurrentLossStreak[duoWin] = 0;
                    duoCurrentWinStreak[duoWin] = (duoCurrentWinStreak[duoWin] || 0) + 1;
                    if (duoCurrentWinStreak[duoWin] > (duoWinStreaks[duoWin] || 0)) {
                        duoWinStreaks[duoWin] = duoCurrentWinStreak[duoWin];
                    }
                }
                
                if (losers.length === 2) {
                    const duoLoss = losers.sort().join(' e ');
                    duoCurrentWinStreak[duoLoss] = 0;
                    duoCurrentLossStreak[duoLoss] = (duoCurrentLossStreak[duoLoss] || 0) + 1;
                    if (duoCurrentLossStreak[duoLoss] > (duoLossStreaks[duoLoss] || 0)) {
                        duoLossStreaks[duoLoss] = duoCurrentLossStreak[duoLoss];
                    }
                }
            });
            
            // Find max streaks
            const maxPlayerWinStreak = Object.entries(playerWinStreaks).sort((a, b) => b[1] - a[1])[0];
            const maxPlayerLossStreak = Object.entries(playerLossStreaks).sort((a, b) => b[1] - a[1])[0];
            const maxDuoWinStreak = Object.entries(duoWinStreaks).sort((a, b) => b[1] - a[1])[0];
            const maxDuoLossStreak = Object.entries(duoLossStreaks).sort((a, b) => b[1] - a[1])[0];
            
            let streaksHTML = '<div class="row">';
            
            if (maxPlayerWinStreak) {
                streaksHTML += `
                    <div class="col-md-6 mb-3">
                        <div class="card border-success">
                            <div class="card-body">
                                <h5 class="card-title text-success"><i class="fas fa-fire"></i> Maior Sequência de Vitórias (Solo)</h5>
                                <p class="card-text"><strong>${maxPlayerWinStreak[0]}</strong> - ${maxPlayerWinStreak[1]} vitória(s) consecutiva(s)</p>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            if (maxPlayerLossStreak) {
                streaksHTML += `
                    <div class="col-md-6 mb-3">
                        <div class="card border-danger">
                            <div class="card-body">
                                <h5 class="card-title text-danger"><i class="fas fa-skull"></i> Maior Sequência de Derrotas (Solo)</h5>
                                <p class="card-text"><strong>${maxPlayerLossStreak[0]}</strong> - ${maxPlayerLossStreak[1]} derrota(s) consecutiva(s)</p>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            if (maxDuoWinStreak) {
                streaksHTML += `
                    <div class="col-md-6 mb-3">
                        <div class="card border-success">
                            <div class="card-body">
                                <h5 class="card-title text-success"><i class="fas fa-fire"></i> Maior Sequência de Vitórias (Dupla)</h5>
                                <p class="card-text"><strong>${maxDuoWinStreak[0]}</strong> - ${maxDuoWinStreak[1]} vitória(s) consecutiva(s)</p>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            if (maxDuoLossStreak) {
                streaksHTML += `
                    <div class="col-md-6 mb-3">
                        <div class="card border-danger">
                            <div class="card-body">
                                <h5 class="card-title text-danger"><i class="fas fa-skull"></i> Maior Sequência de Derrotas (Dupla)</h5>
                                <p class="card-text"><strong>${maxDuoLossStreak[0]}</strong> - ${maxDuoLossStreak[1]} derrota(s) consecutiva(s)</p>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            streaksHTML += '</div>';
            document.getElementById('streaks-content').innerHTML = streaksHTML;
        }
        
        function generateWeeklyStats(matches, playersData) {
            // Group matches by week
            const weeklyStats = {};
            
            matches.forEach(match => {
                const matchDate = new Date(match.date || match.timestamp);
                const year = matchDate.getFullYear();
                const week = getWeekNumber(matchDate);
                const weekKey = `${year}-W${week.toString().padStart(2, '0')}`;
                
                const winners = Array.isArray(match.winners) ? match.winners : [match.winners];
                const losers = Array.isArray(match.losers) ? match.losers : [match.losers];
                
                [...winners, ...losers].forEach(player => {
                    if (!weeklyStats[player]) {
                        weeklyStats[player] = {};
                    }
                    if (!weeklyStats[player][weekKey]) {
                        weeklyStats[player][weekKey] = { wins: 0, losses: 0 };
                    }
                });
                
                winners.forEach(winner => {
                    weeklyStats[winner][weekKey].wins++;
                });
                
                losers.forEach(loser => {
                    weeklyStats[loser][weekKey].losses++;
                });
            });
            
            const tbody = document.getElementById('weekly-stats-body');
            
            // Create array with all stats for sorting
            const statsArray = [];
            Object.entries(weeklyStats).forEach(([player, weeks]) => {
                Object.entries(weeks).forEach(([week, stats]) => {
                    const total = stats.wins + stats.losses;
                    const winRate = total > 0 ? ((stats.wins / total) * 100) : 0;
                    statsArray.push({
                        player,
                        week,
                        wins: stats.wins,
                        losses: stats.losses,
                        winRate
                    });
                });
            });
            
            // Sort by win rate (descending)
            statsArray.sort((a, b) => b.winRate - a.winRate);
            
            // Create rows
            statsArray.forEach(stat => {
                const winRateStr = stat.winRate > 0 ? stat.winRate.toFixed(2) + '%' : '0.00%';
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td><strong>${stat.player}</strong></td>
                    <td>${stat.week}</td>
                    <td class="text-success">${stat.wins}</td>
                    <td class="text-danger">${stat.losses}</td>
                    <td><strong>${winRateStr}</strong></td>
                `;
                tbody.appendChild(row);
            });
            
            if (tbody.children.length === 0) {
                tbody.innerHTML = '<tr><td colspan="5" class="text-center text-muted">Nenhum dado semanal disponível.</td></tr>';
            }
        }
        
        function getWeekNumber(date) {
            const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
            const dayNum = d.getUTCDay() || 7;
            d.setUTCDate(d.getUTCDate() + 4 - dayNum);
            const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
            return Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
        }
    </script>
</body>
</html>

